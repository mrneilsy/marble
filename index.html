<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Rolling Ball Physics Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .joystick-container {
            position: absolute;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        #joystick-move {
            bottom: 20px;
            right: 20px;
        }
        #joystick-rotate {
            bottom: 20px;
            left: 20px;
        }
        .joystick {
            width: 50px;
            height: 50px;
            background-color: #ff5733;
            border-radius: 50%;
            position: absolute;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Speed: <span id="speed">0.00</span> | Height: <span id="height">0.00</span></div>
    <div class="joystick-container" id="joystick-move">
        <div class="joystick"></div>
    </div>
    <div class="joystick-container" id="joystick-rotate">
        <div class="joystick"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, ball, terrain;
        let velocity = { x: 0, y: 0, z: 0 };
        let angularVelocity = { x: 0, y: 0, z: 0 };
        let moveVector = { x: 0, z: 0 };
        let rotationAngle = 0;
        let isOnGround = true;
        let obstacles = [];
        let ramps = [];
        const terrainSize = 400;
        const ballRadius = 3;
        let speedDisplay = document.getElementById('speed');
        let heightDisplay = document.getElementById('height');

        // Physics constants - improved values for more realistic physics
        const GRAVITY = 0.05;
        const GROUND_FRICTION = 0.02;
        const AIR_RESISTANCE = 0.995;
        const BALL_ROTATION_FACTOR = 0.5;
        const RESTITUTION = 0.8;  // More realistic bounce factor

        // Collision detection helpers
        const raycaster = new THREE.Raycaster();
        const ballDirection = new THREE.Vector3();

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Create Ball
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                specular: 0x333333,
                shininess: 30
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, ballRadius + 5, 0); // Start a bit above the ground
            ball.castShadow = true;
            ball.receiveShadow = false;
            scene.add(ball);

            // Create Terrain
            const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 1, 1);
            const terrainMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x228B22, 
                wireframe: false
            });
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Add Grid Lines
            const gridHelper = new THREE.GridHelper(terrainSize, 40, 0x000000, 0x444444);
            gridHelper.position.y = 0.1; // Slightly above the terrain to avoid z-fighting
            scene.add(gridHelper);

            // Add boundaries to keep the ball in play
            createBoundaries();

            // Add obstacles
            createObstacles();

            // Add ramps
            createRamps();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x666666);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 300;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Position camera
            camera.position.set(0, 30, 50);
            camera.lookAt(ball.position);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Start animation
            animate();
        }

        function createBoundaries() {
            const wallHeight = 10;
            const wallThickness = 5;
            const wallColor = 0x444444;
            const wallMaterial = new THREE.MeshPhongMaterial({ color: wallColor });
            
            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(terrainSize + wallThickness * 2, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -terrainSize / 2 - wallThickness / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            northWall.userData.isWall = true;
            scene.add(northWall);
            obstacles.push(northWall);
            
            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(terrainSize + wallThickness * 2, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, terrainSize / 2 + wallThickness / 2);
            southWall.castShadow = true;
            southWall.receiveShadow = true;
            southWall.userData.isWall = true;
            scene.add(southWall);
            obstacles.push(southWall);
            
            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, terrainSize + wallThickness * 2),
                wallMaterial
            );
            eastWall.position.set(terrainSize / 2 + wallThickness / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            eastWall.userData.isWall = true;
            scene.add(eastWall);
            obstacles.push(eastWall);
            
            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, terrainSize + wallThickness * 2),
                wallMaterial
            );
            westWall.position.set(-terrainSize / 2 - wallThickness / 2, wallHeight / 2, 0);
            westWall.castShadow = true;
            westWall.receiveShadow = true;
            westWall.userData.isWall = true;
            scene.add(westWall);
            obstacles.push(westWall);
        }

        function createObstacles() {
            // Create some random obstacles
            const obstacleCount = 15;
            const obstacleColors = [0xf39c12, 0x3498db, 0x9b59b6, 0x2ecc71, 0xe74c3c];
            
            for (let i = 0; i < obstacleCount; i++) {
                // Random position within terrain bounds
                const x = (Math.random() - 0.5) * (terrainSize - 20);
                const z = (Math.random() - 0.5) * (terrainSize - 20);
                
                // Random size
                const width = 5 + Math.random() * 15;
                const height = 5 + Math.random() * 15;
                const depth = 5 + Math.random() * 15;
                
                // Random color
                const color = obstacleColors[Math.floor(Math.random() * obstacleColors.length)];
                
                // Create obstacle
                const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
                const obstacleMaterial = new THREE.MeshPhongMaterial({ color: color });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                
                // Position obstacle
                obstacle.position.set(x, height / 2, z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                obstacle.userData.isBox = true;
                
                // Add to scene and obstacles array
                scene.add(obstacle);
                obstacles.push(obstacle);
            }

            // Add some cylinders too
            for (let i = 0; i < 10; i++) {
                const x = (Math.random() - 0.5) * (terrainSize - 20);
                const z = (Math.random() - 0.5) * (terrainSize - 20);
                const radius = 3 + Math.random() * 7;
                const height = 8 + Math.random() * 15;
                
                const color = obstacleColors[Math.floor(Math.random() * obstacleColors.length)];
                
                const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 16);
                const cylinderMaterial = new THREE.MeshPhongMaterial({ color: color });
                const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                
                cylinder.position.set(x, height / 2, z);
                cylinder.castShadow = true;
                cylinder.receiveShadow = true;
                cylinder.userData.isCylinder = true;
                cylinder.userData.radius = radius;
                
                scene.add(cylinder);
                obstacles.push(cylinder);
            }
        }

        function createRamps() {
            // Create several ramps around the terrain
            const rampPositions = [
                { x: 50, z: -80, rotation: 0, size: { width: 30, height: 15, depth: 60 } },
                { x: -70, z: 60, rotation: Math.PI / 2, size: { width: 30, height: 10, depth: 40 } },
                { x: -40, z: -40, rotation: Math.PI / 4, size: { width: 25, height: 12, depth: 50 } },
                { x: 80, z: 30, rotation: -Math.PI / 3, size: { width: 35, height: 18, depth: 70 } }
            ];
            
            rampPositions.forEach(rampData => {
                createRamp(
                    rampData.x, 
                    rampData.z, 
                    rampData.rotation, 
                    rampData.size.width, 
                    rampData.size.height, 
                    rampData.size.depth
                );
            });
        }

        function createRamp(x, z, rotation, width, height, depth) {
            // Create a ramp using a custom geometry
            const rampGeometry = new THREE.BufferGeometry();
            
            // Define the vertices of the ramp (triangular prism)
            const vertices = new Float32Array([
                // Front face (triangle)
                -width/2, 0, depth/2,
                width/2, 0, depth/2,
                0, height, depth/2,
                
                // Back face (triangle)
                -width/2, 0, -depth/2,
                width/2, 0, -depth/2,
                0, height, -depth/2,
                
                // Bottom face (rectangle)
                -width/2, 0, depth/2,
                width/2, 0, depth/2,
                width/2, 0, -depth/2,
                -width/2, 0, -depth/2,
                
                // Left face (triangle)
                -width/2, 0, depth/2,
                -width/2, 0, -depth/2,
                0, height, depth/2,
                0, height, -depth/2,
                
                // Right face (triangle)
                width/2, 0, depth/2,
                width/2, 0, -depth/2,
                0, height, depth/2,
                0, height, -depth/2
            ]);
            
            // Define the faces using indices
            const indices = [
                // Front face
                0, 1, 2,
                
                // Back face
                4, 3, 5,
                
                // Bottom face
                6, 7, 8,
                6, 8, 9,
                
                // Left face
                10, 11, 12,
                11, 13, 12,
                
                // Right face
                14, 16, 15,
                15, 16, 17
            ];
            
            // Set up the geometry
            rampGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            rampGeometry.setIndex(indices);
            rampGeometry.computeVertexNormals();
            
            // Create the mesh
            const rampMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf39c12, 
                side: THREE.DoubleSide 
            });
            const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
            
            // Position and rotate the ramp
            ramp.position.set(x, 0, z);
            ramp.rotation.y = rotation;
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            ramp.userData.isRamp = true;
            
            // Add to scene and ramps array
            scene.add(ramp);
            ramps.push(ramp);
            obstacles.push(ramp); // Add to obstacles for collision detection
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateCamera();
            updateDisplay();
            renderer.render(scene, camera);
        }

        function updatePhysics() {
            // Calculate movement direction relative to camera
            const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
            
            const moveDirection = new THREE.Vector3()
                .addScaledVector(forward, -moveVector.z)  // Forward/backward
                .addScaledVector(right, moveVector.x);    // Left/right
            
            // Apply input force 
            const forceFactor = isOnGround ? 0.2 : 0.05; // Less control in air
            velocity.x += moveDirection.x * forceFactor;
            velocity.z += moveDirection.z * forceFactor;
            
            // Apply gravity
            velocity.y -= GRAVITY;
            
            // Store previous position for collision response
            const prevPosition = new THREE.Vector3().copy(ball.position);
            
            // Update position with velocity
            ball.position.x += velocity.x;
            ball.position.y += velocity.y;
            ball.position.z += velocity.z;
            
            // Ground collision with restitution
            handleGroundCollision();
            
            // Handle obstacle collisions with improved detection
            handleObstacleCollisions(prevPosition);
            
            // Apply air resistance
            velocity.x *= AIR_RESISTANCE;
            velocity.y *= AIR_RESISTANCE;
            velocity.z *= AIR_RESISTANCE;
            
            // Ground friction when on ground
            if (isOnGround) {
                velocity.x *= (1 - GROUND_FRICTION);
                velocity.z *= (1 - GROUND_FRICTION);
            }
            
            // Rotate the ball based on movement (improved physics)
            if (isOnGround) {
                // Calculate rotation axis perpendicular to movement direction
                const movementDir = new THREE.Vector3(velocity.x, 0, velocity.z).normalize();
                const rotationAxis = new THREE.Vector3(-velocity.z, 0, velocity.x).normalize();
                
                // Calculate angular velocity based on linear velocity and ball radius
                const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                const angularSpeed = speed / ballRadius;
                
                // Apply rotation
                if (speed > 0.01) {
                    const rotQuat = new THREE.Quaternion();
                    rotQuat.setFromAxisAngle(rotationAxis, angularSpeed * BALL_ROTATION_FACTOR);
                    ball.quaternion.premultiply(rotQuat);
                }
            }
        }

        function handleGroundCollision() {
            if (ball.position.y <= ballRadius) {
                ball.position.y = ballRadius;
                
                // Calculate bounce with proper restitution
                if (velocity.y < 0) {
                    velocity.y = -velocity.y * RESTITUTION;
                    
                    // If velocity is very small, just stop it
                    if (Math.abs(velocity.y) < 0.1) {
                        velocity.y = 0;
                        isOnGround = true;
                    }
                }
            } else {
                isOnGround = false;
            }
        }

        function handleObstacleCollisions(prevPosition) {
            const ballPosition = new THREE.Vector3(ball.position.x, ball.position.y, ball.position.z);
            
            // Create a bounding sphere for the ball
            const ballBoundingSphere = new THREE.Sphere(ballPosition, ballRadius);
            
            // Get movement direction for this frame
            const movementDir = new THREE.Vector3()
                .subVectors(ballPosition, prevPosition)
                .normalize();
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // Use different collision detection based on obstacle type
                if (obstacle.userData.isCylinder) {
                    handleCylinderCollision(obstacle, ballBoundingSphere, movementDir);
                } else {
                    // Box objects and walls
                    handleBoxCollision(obstacle, ballBoundingSphere, prevPosition);
                }
            }
            
            // Ensure we're still within terrain bounds
            checkTerrainBoundaries();
        }

        function handleCylinderCollision(cylinder, ballSphere, movementDir) {
            // Get cylinder parameters
            const cylinderRadius = cylinder.userData.radius;
            const cylinderHeight = cylinder.geometry.parameters.height;
            const cylinderPosition = cylinder.position.clone();
            
            // Get horizontal distance from cylinder center to ball center
            const horizontalDiff = new THREE.Vector2(
                ballSphere.center.x - cylinderPosition.x,
                ballSphere.center.z - cylinderPosition.z
            );
            const horizontalDistance = horizontalDiff.length();
            
            // Calculate the vertical bounds of the cylinder
            const cylinderTop = cylinderPosition.y + cylinderHeight / 2;
            const cylinderBottom = cylinderPosition.y - cylinderHeight / 2;
            
            // Check if ball is within cylinder's height range
            if (ballSphere.center.y + ballRadius > cylinderBottom && 
                ballSphere.center.y - ballRadius < cylinderTop) {
                
                // Check horizontal collision
                if (horizontalDistance < cylinderRadius + ballRadius) {
                    // Collision detected! Calculate normal vector
                    const normal = new THREE.Vector3(
                        horizontalDiff.x / horizontalDistance,
                        0,
                        horizontalDiff.y / horizontalDistance
                    );
                    
                    // Calculate penetration depth
                    const penetrationDepth = (cylinderRadius + ballRadius) - horizontalDistance;
                    
                    // Push ball out of collision
                    ballSphere.center.x += normal.x * penetrationDepth;
                    ballSphere.center.z += normal.z * penetrationDepth;
                    
                    // Update ball position
                    ball.position.copy(ballSphere.center);
                    
                    // Calculate reflection vector for velocity
                    const dotProduct = velocity.x * normal.x + velocity.z * normal.z;
                    velocity.x = (velocity.x - 2 * dotProduct * normal.x) * RESTITUTION;
                    velocity.z = (velocity.z - 2 * dotProduct * normal.z) * RESTITUTION;
                    
                    // Check if we're on top of the cylinder
                    if (ballSphere.center.y - ballRadius <= cylinderTop && 
                        ballSphere.center.y > cylinderPosition.y && 
                        horizontalDistance < cylinderRadius) {
                        isOnGround = true;
                        if (velocity.y < 0) velocity.y = 0;
                    }
                }
            }
        }

        function handleBoxCollision(box, ballSphere, prevPosition) {
            // Get box bounding box
            const boundingBox = new THREE.Box3().setFromObject(box);
            
            // Check if sphere intersects with the box
            if (checkSphereBoxIntersection(ballSphere, boundingBox)) {
                // Find closest point on box to ball center
                const closestPoint = new THREE.Vector3().copy(ballSphere.center);
                
                // Clamp point to box boundaries
                closestPoint.clamp(boundingBox.min, boundingBox.max);
                
                // Calculate normal vector from closest point to ball center
                const normal = new THREE.Vector3().subVectors(ballSphere.center, closestPoint).normalize();
                
                // Calculate distance
                const distance = ballSphere.center.distanceTo(closestPoint);
                
                // If distance is less than radius, we have collision
                if (distance < ballRadius) {
                    // Calculate penetration depth
                    const penetrationDepth = ballRadius - distance;
                    
                    // Move ball out of collision along normal
                    ballSphere.center.addScaledVector(normal, penetrationDepth);
                    
                    // Update ball position
                    ball.position.copy(ballSphere.center);
                    
                    // Reflect velocity with energy loss
                    const dot = velocity.dot(normal);
                    velocity.subScaledVector(normal, 2 * dot).multiplyScalar(RESTITUTION);
                    
                    // Check if normal is pointing up - we might be on a surface
                    if (normal.y > 0.7) {
                        isOnGround = true;
                        if (velocity.y < 0) velocity.y = 0;
                    }
                    
                    // Add a small random variation for natural rebounds
                    if (!box.userData.isWall) {
                        velocity.x += (Math.random() - 0.5) * 0.02;
                        velocity.z += (Math.random() - 0.5) * 0.02;
                    }
                }
            }
        }

        function checkSphereBoxIntersection(sphere, box) {
            // Find the closest point on the box to the sphere center
            const closestPoint = new THREE.Vector3().copy(sphere.center);
            closestPoint.clamp(box.min, box.max);
            
            // Calculate squared distance
            const distanceSquared = closestPoint.distanceToSquared(sphere.center);
            
            // If distance is less than radius squared, we have intersection
            return distanceSquared < (sphere.radius * sphere.radius);
        }

        function checkTerrainBoundaries() {
            const halfSize = terrainSize / 2;
            
            // Keep ball within terrain boundaries
            if (ball.position.x > halfSize - ballRadius) {
                ball.position.x = halfSize - ballRadius;
                velocity.x = -velocity.x * RESTITUTION;
            }
            if (ball.position.x < -halfSize + ballRadius) {
                ball.position.x = -halfSize + ballRadius;
                velocity.x = -velocity.x * RESTITUTION;
            }
            if (ball.position.z > halfSize - ballRadius) {
                ball.position.z = halfSize - ballRadius;
                velocity.z = -velocity.z * RESTITUTION;
            }
            if (ball.position.z < -halfSize + ballRadius) {
                ball.position.z = -halfSize + ballRadius;
                velocity.z = -velocity.z * RESTITUTION;
            }
        }

        function updateCamera() {
            // Calculate distance based on ball's height for a dynamic camera
            const baseDistance = 30;
            const heightFactor = 1.5;
            const distance = baseDistance + ball.position.y * heightFactor;
            
            // Calculate camera position based on rotation angle and distance
            const camX = ball.position.x + Math.sin(rotationAngle) * distance;
            const camZ = ball.position.z + Math.cos(rotationAngle) * distance;
            
            // Calculate camera height based on ball's height
            const camHeight = Math.max(20, ball.position.y + 15);
            
            // Smoothly interpolate camera position for a more cinematic effect
            camera.position.x += (camX - camera.position.x) * 0.1;
            camera.position.y += (camHeight - camera.position.y) * 0.1;
            camera.position.z += (camZ - camera.position.z) * 0.1;
            
            // Always look at the ball
            camera.lookAt(ball.position);
        }

        function updateDisplay() {
            // Calculate speed (magnitude of velocity)
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            
            // Update display
            speedDisplay.textContent = speed.toFixed(2);
            heightDisplay.textContent = (ball.position.y - ballRadius).toFixed(2);
        }

        function handleJoystick(event, joystickType) {
            let touch = event.touches ? event.touches[0] : event;
            let rect = event.target.parentElement.getBoundingClientRect();
            let centerX = rect.left + rect.width / 2;
            let centerY = rect.top + rect.height / 2;

            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            let maxRadius = rect.width / 2 - 10;

            if (distance > maxRadius) {
                let angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxRadius;
                deltaY = Math.sin(angle) * maxRadius;
            }

            event.target.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

            // Normalize movement
            if (joystickType === "move") {
                moveVector.x = deltaX / maxRadius;
                moveVector.z = deltaY / maxRadius;
            } else if (joystickType === "rotate") {
                rotationAngle -= (deltaX / maxRadius) * 0.1;
            }
        }

        function resetJoystick(event, joystickType) {
            event.target.style.transform = "translate(0, 0)";
            if (joystickType === "move") {
                moveVector.x = 0;
                moveVector.z = 0;
            }
        }

        // Event Listeners
        document.querySelector("#joystick-move .joystick").addEventListener("touchstart", function(e) {
            e.preventDefault();
            this.addEventListener("touchmove", function(e) {
                e.preventDefault();
                handleJoystick(e, "move");
            });
        });

        document.querySelector("#joystick-move .joystick").addEventListener("touchend", function(e) {
            e.preventDefault();
            resetJoystick(e, "move");
            this.removeEventListener("touchmove", handleJoystick);
        });

        document.querySelector("#joystick-rotate .joystick").addEventListener("touchstart", function(e) {
            e.preventDefault();
            this.addEventListener("touchmove", function(e) {
                e.preventDefault();
                handleJoystick(e, "rotate");
            });
        });

        document.querySelector("#joystick-rotate .joystick").addEventListener("touchend", function(e) {
            e.preventDefault();
            resetJoystick(e, "rotate");
            this.removeEventListener("touchmove", handleJoystick);
        });

        // Mouse event listeners
        let moveDrag = false;
        let rotateDrag = false;

        document.querySelector("#joystick-move .joystick").addEventListener("mousedown", function(e) {
            moveDrag = true;
        });

        document.querySelector("#joystick-rotate .joystick").addEventListener("mousedown", function(e) {
            rotateDrag = true;
        });

        document.addEventListener("mousemove", function(e) {
            if (moveDrag) {
                handleJoystick(e, "move");
            }
            if (rotateDrag) {
                handleJoystick(e, "rotate");
            }
        });

        // Here's the end of the document.addEventListener("mouseup") function that was cut off:
		document.addEventListener("mouseup", function(e) {
			if (moveDrag) {
				resetJoystick(e, "move");
				moveDrag = false;
			}
			if (rotateDrag) {
				resetJoystick(e, "rotate");
				rotateDrag = false;
			}
		});

		// Keyboard controls for desktop
		document.addEventListener("keydown", function(e) {
			switch(e.key) {
				case "ArrowUp":
				case "w": moveVector.z = -1; break;
				case "ArrowDown":
				case "s": moveVector.z = 1; break;
				case "ArrowLeft":
				case "a": moveVector.x = -1; break;
				case "ArrowRight":
				case "d": moveVector.x = 1; break;
				case "q": rotationAngle += 0.1; break;
				case "e": rotationAngle -= 0.1; break;
			}
		});

		document.addEventListener("keyup", function(e) {
			switch(e.key) {
				case "ArrowUp":
				case "w":
				case "ArrowDown":
				case "s": moveVector.z = 0; break;
				case "ArrowLeft":
				case "a":
				case "ArrowRight":
				case "d": moveVector.x = 0; break;
			}
		});

		// Initialize the game
		window.onload = init;

		// Improved collision functions
		function handleBoxCollision(box, ballSphere, prevPosition) {
			// Get box bounding box
			const boundingBox = new THREE.Box3().setFromObject(box);
			
			// Check if sphere intersects with the box
			if (checkSphereBoxIntersection(ballSphere, boundingBox)) {
				// Find closest point on box to ball center
				const closestPoint = new THREE.Vector3().copy(ballSphere.center);
				closestPoint.clamp(boundingBox.min, boundingBox.max);
				
				// Calculate normal vector from closest point to ball center
				const normal = new THREE.Vector3().subVectors(ballSphere.center, closestPoint).normalize();
				
				// Calculate distance
				const distance = ballSphere.center.distanceTo(closestPoint);
				
				// If distance is less than radius, we have collision
				if (distance < ballRadius) {
					// Calculate penetration depth
					const penetrationDepth = ballRadius - distance;
					
					// Move ball out of collision along normal
					ballSphere.center.addScaledVector(normal, penetrationDepth);
					
					// Update ball position
					ball.position.copy(ballSphere.center);
					
					// Calculate impact velocity
					const impactVelocity = new THREE.Vector3(velocity.x, velocity.y, velocity.z);
					const impactSpeed = impactVelocity.length();
					
					// Reflect velocity with energy loss and friction
					const dot = velocity.dot(normal);
					
					// Only reflect if moving toward the surface
					if (dot < 0) {
						// Add elasticity
						velocity.subScaledVector(normal, 2 * dot).multiplyScalar(RESTITUTION);
						
						// Add surface friction (tangential velocity reduction)
						const tangent = new THREE.Vector3(velocity.x, velocity.y, velocity.z);
						tangent.addScaledVector(normal, -tangent.dot(normal)).normalize();
						
						// Reduce tangential velocity component based on impact speed
						const frictionFactor = Math.min(GROUND_FRICTION * impactSpeed, 0.95);
						velocity.addScaledVector(tangent, -frictionFactor * tangent.dot(velocity));
						
						// Check if normal is pointing up - we might be on a surface
						if (normal.y > 0.7) {
							isOnGround = true;
							if (velocity.y < 0) velocity.y = 0;
						}
						
						// Add a small random variation for natural rebounds
						if (!box.userData.isWall) {
							const randomFactor = Math.min(0.05, impactSpeed * 0.01);
							velocity.x += (Math.random() - 0.5) * randomFactor;
							velocity.z += (Math.random() - 0.5) * randomFactor;
						}
						
						// Add impact sound if speed is significant
						if (impactSpeed > 1.0) {
							// playImpactSound(impactSpeed); // Uncomment if you add sound
						}
					}
				}
			}
		}

		function handleCylinderCollision(cylinder, ballSphere, movementDir) {
			// Get cylinder parameters
			const cylinderRadius = cylinder.userData.radius;
			const cylinderHeight = cylinder.geometry.parameters.height;
			const cylinderPosition = cylinder.position.clone();
			
			// Apply cylinder's world transformation (for rotated cylinders)
			const cylinderMatrix = cylinder.matrixWorld;
			const cylinderUp = new THREE.Vector3(0, 1, 0).applyMatrix4(cylinderMatrix).normalize();
			
			// Project ball center onto cylinder axis
			const cylinderToSphere = new THREE.Vector3().subVectors(ballSphere.center, cylinderPosition);
			const dotProduct = cylinderToSphere.dot(cylinderUp);
			const axisPoint = new THREE.Vector3().copy(cylinderPosition).addScaledVector(cylinderUp, dotProduct);
			
			// Calculate distance from axis
			const radialVector = new THREE.Vector3().subVectors(ballSphere.center, axisPoint);
			const radialDistance = radialVector.length();
			
			// Calculate height position relative to cylinder ends
			const heightPosition = Math.abs(dotProduct);
			const isWithinHeight = heightPosition <= cylinderHeight / 2;
			
			// Check if we're colliding with cylinder body
			if (isWithinHeight && radialDistance < cylinderRadius + ballRadius) {
				// Normalize the radial vector
				if (radialDistance > 0.001) {
					radialVector.normalize();
				} else {
					// If we're exactly on the axis, use a random direction
					radialVector.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
				}
				
				// Calculate penetration depth
				const penetrationDepth = (cylinderRadius + ballRadius) - radialDistance;
				
				// Move ball out of collision
				ballSphere.center.addScaledVector(radialVector, penetrationDepth);
				ball.position.copy(ballSphere.center);
				
				// Calculate impact velocity
				const impactVelocity = new THREE.Vector3(velocity.x, velocity.y, velocity.z);
				const impactSpeed = impactVelocity.length();
				
				// Calculate reflection
				const normalDot = velocity.dot(radialVector);
				
				// Only reflect if moving toward the surface
				if (normalDot < 0) {
					velocity.subScaledVector(radialVector, 2 * normalDot).multiplyScalar(RESTITUTION);
					
					// Add surface friction
					const tangent = new THREE.Vector3(velocity.x, velocity.y, velocity.z);
					tangent.addScaledVector(radialVector, -tangent.dot(radialVector)).normalize();
					
					const frictionFactor = Math.min(GROUND_FRICTION * impactSpeed, 0.95);
					velocity.addScaledVector(tangent, -frictionFactor * tangent.dot(velocity));
					
					// Add small random variation
					const randomFactor = Math.min(0.05, impactSpeed * 0.01);
					velocity.x += (Math.random() - 0.5) * randomFactor;
					velocity.z += (Math.random() - 0.5) * randomFactor;
				}
				
				return true;
			}
			
			// Check for collision with cylinder ends (caps)
			const endPoint1 = new THREE.Vector3().copy(cylinderPosition).addScaledVector(cylinderUp, cylinderHeight / 2);
			const endPoint2 = new THREE.Vector3().copy(cylinderPosition).addScaledVector(cylinderUp, -cylinderHeight / 2);
			
			const endPoints = [endPoint1, endPoint2];
			for (let i = 0; i < endPoints.length; i++) {
				const endPoint = endPoints[i];
				const endToSphere = new THREE.Vector3().subVectors(ballSphere.center, endPoint);
				const distance = endToSphere.length();
				
				if (distance < ballRadius) {
					// Normalize direction
					if (distance > 0.001) {
						endToSphere.normalize();
					} else {
						endToSphere.copy(cylinderUp).multiplyScalar(i === 0 ? 1 : -1);
					}
					
					// Calculate penetration and move ball
					const penetrationDepth = ballRadius - distance;
					ballSphere.center.addScaledVector(endToSphere, penetrationDepth);
					ball.position.copy(ballSphere.center);
					
					// Calculate reflection
					const normalDot = velocity.dot(endToSphere);
					
					// Only reflect if moving toward the surface
					if (normalDot < 0) {
						velocity.subScaledVector(endToSphere, 2 * normalDot).multiplyScalar(RESTITUTION);
						
						// Check if we're on top cap
						if (i === 0 && endToSphere.y > 0.7) {
							isOnGround = true;
							if (velocity.y < 0) velocity.y = 0;
						}
					}
					
					return true;
				}
			}
			
			return false;
		}

		// Improved ramp collision detection
		function handleRampCollision(ramp, ballSphere) {
			// We need a specialized collision detection for our custom ramp geometry
			// This is a simplified approach using raycasting
			
			// Cast rays from the ball in several directions, especially downward
			const directions = [
				new THREE.Vector3(0, -1, 0),  // Down
				new THREE.Vector3(0.5, -0.5, 0).normalize(),  // Down-right
				new THREE.Vector3(-0.5, -0.5, 0).normalize(), // Down-left
				new THREE.Vector3(0, -0.5, 0.5).normalize(),  // Down-forward
				new THREE.Vector3(0, -0.5, -0.5).normalize()  // Down-backward
			];
			
			let collision = false;
			let closestDistance = Number.MAX_VALUE;
			let closestNormal = new THREE.Vector3();
			
			for (let dir of directions) {
				// Set up raycaster from ball center
				raycaster.set(ballSphere.center, dir);
				
				// Get intersections with the ramp
				const intersects = raycaster.intersectObject(ramp);
				
				if (intersects.length > 0 && intersects[0].distance < ballRadius) {
					collision = true;
					
					// Find the closest intersection point
					if (intersects[0].distance < closestDistance) {
						closestDistance = intersects[0].distance;
						closestNormal = intersects[0].face.normal.clone();
						
						// Transform normal from local to world space
						closestNormal.transformDirection(ramp.matrixWorld);
					}
				}
			}
			
			if (collision) {
				// Calculate penetration depth
				const penetrationDepth = ballRadius - closestDistance;
				
				// Move ball out of collision
				ballSphere.center.addScaledVector(closestNormal, penetrationDepth);
				ball.position.copy(ballSphere.center);
				
				// Calculate reflection
				const normalDot = velocity.dot(closestNormal);
				
				// Only reflect if moving toward the surface
				if (normalDot < 0) {
					velocity.subScaledVector(closestNormal, 2 * normalDot).multiplyScalar(RESTITUTION);
					
					// Calculate if we're on top of the ramp (normal pointing somewhat up)
					if (closestNormal.y > 0.2) {
						isOnGround = true;
						
						// Apply slip effect on sloped surfaces based on incline
						const slopeFactor = 1.0 - closestNormal.y; // 0 for flat, 1 for vertical
						
						// Add gravitational acceleration along the slope
						if (slopeFactor > 0.1) {
							// Calculate slope direction (project gravity onto slope)
							const slopeDir = new THREE.Vector3(0, -1, 0)
								.addScaledVector(closestNormal, -closestNormal.y)
								.normalize();
							
							// Add acceleration based on slope steepness
							velocity.addScaledVector(slopeDir, GRAVITY * slopeFactor * 0.5);
						}
					}
				}
				
				return true;
			}
			
			return false;
		}

		function handleObstacleCollisions(prevPosition) {
			const ballPosition = new THREE.Vector3(ball.position.x, ball.position.y, ball.position.z);
			
			// Create a bounding sphere for the ball
			const ballBoundingSphere = new THREE.Sphere(ballPosition, ballRadius);
			
			// Get movement direction for this frame
			const movementDir = new THREE.Vector3()
				.subVectors(ballPosition, prevPosition)
				.normalize();
			
			// Flag to track if collision occurred
			let collisionOccurred = false;
			
			// First handle ramp collisions as they have different geometry
			for (let i = 0; i < ramps.length; i++) {
				if (handleRampCollision(ramps[i], ballBoundingSphere)) {
					collisionOccurred = true;
				}
			}
			
			// Then handle other obstacles
			for (let i = 0; i < obstacles.length; i++) {
				const obstacle = obstacles[i];
				
				// Skip ramps as we handled them separately
				if (obstacle.userData.isRamp) continue;
				
				// Use different collision detection based on obstacle type
				if (obstacle.userData.isCylinder) {
					if (handleCylinderCollision(obstacle, ballBoundingSphere, movementDir)) {
						collisionOccurred = true;
					}
				} else {
					// Box objects and walls
					if (checkSphereBoxIntersection(ballBoundingSphere, new THREE.Box3().setFromObject(obstacle))) {
						handleBoxCollision(obstacle, ballBoundingSphere, prevPosition);
						collisionOccurred = true;
					}
				}
			}
			
			// If a collision occurred, update the ball's position
			if (collisionOccurred) {
				ball.position.copy(ballBoundingSphere.center);
			}
			
			// Ensure we're still within terrain boundaries
			checkTerrainBoundaries();
		}

		// Add function to play sound effects
		function playImpactSound(impactSpeed) {
			// Implementation would go here if you add sound
			// Could use WebAudio API to generate sounds dynamically
			// or load audio samples based on impact strength
		}

		// Optional: Add particle effects for strong impacts
		function createImpactParticles(position, normal, impactStrength) {
			// Implementation would go here if you add particle effects
		}

		// Launch the game
		init();
						
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				